---
title: Full Stack Project Part 1 - Todo List
---

# Full Stack Project Part 1 - Todo List


<img src="https://cdni.iconscout.com/illustration/premium/thumb/programmer-2496183-2107739.png" />

## Introduction

We are now at the climax of the program where we will be building a full stack project. This project will be a culmination of all the skills you have learned so far.

A full stack project is a project that has a front end and a back end. The front end is the part of the application that the user interacts with. The back end is responsible for storing data and processing data and sending it to the front end.

We will be creating a full stack project using Ruby on Rails for the back end and Angular for the front end.

We will create a todo list application. This application will allow users to create a todo list and add items to the todo list.

## Creating a Simple Rails API for a Todo List application

We will start by creating the Rails API for the todo list.

### Setting up the Rails API

We will start by creating the Rails API. We will create a new Rails API using the following command:

```bash
rails new todo_list_api --api
```

### Creating Tests with RSpec

To remove all Minitest files which are test files generated by default in a Rails project, run the following command:

```bash
rm -rf test/
```

Let's create our testing environment by including gems for testing in the Gemfile.

```ruby
group :development, :test do
  # See https://guides.rubyonrails.org/debugging_rails_applications.html#debugging-with-the-debug-gem
  gem "debug", platforms: %i[ mri mingw x64_mingw ]
  gem 'rspec-rails'
  gem 'factory_bot_rails'
  gem 'faker'
end
```

```bash
bundle install
```

```bash
rails generate rspec:install
```

Be sure to include

```ruby
require 'faker'
.
.
.
```

in the `rails_helper.rb` file.

To use Factory-Bot, we need to add the following to our `rails_helper.rb` file:

```ruby
.
.
.
RSpec.configure do |config|
  config.include FactoryBot::Syntax::Methods
  .
  .
  .
end
```

Next, run the following command to generate the RSpec configuration files:

Let's create an RSpec file for the todo model.

```bash
rails generate rspec:model Todo
```

Let's add a factory for the todo model.

```ruby
FactoryBot.define do
  factory :todo do
    body { Faker::Lorem.sentence }
    is_completed { false }
  end
end
```

>**üí° Curious about how to organize your test files or when to use factories in Rails?**  
> Ask the [Codelabs Learning Assistant](https://chatgpt.com/g/g-68484cbcb348819181c3f4137b0b7c49-codelabs-learning-assistant): ‚ÄúWhat‚Äôs the best way to structure my RSpec tests and use FactoryBot for different models?‚Äù

#### Rspec for the Todo Model

Let's create tests for the todo model.

```ruby
require 'rails_helper'

RSpec.describe Todo, type: :model do

  context "valid attributes" do
    it "is valid with valid attributes" do
      todo = build(:todo)
      expect(todo).to be_valid
    end
  end

  context "invalid attributes" do
    it "is invalid without a body" do
      todo = build(:todo, body: nil)
      todo.valid?
      expect(todo.errors[:body]).to include("can't be blank")
    end

    it "is invalid when body is too long" do
      todo = build(:todo, body: "a" * 256)
      todo.valid?
      expect(todo.errors[:body]).to include("is too long (maximum is 255 characters)")
    end

    it "is invalid without a is_completed" do
      todo = build(:todo, is_completed: nil)
      todo.valid?
      expect(todo.errors[:is_completed]).to include("is not included in the list")
    end
  end
end
```

#### Rspec for the Todo Controller

Let's create a test for the todo controller.

```bash
rails generate rspec:request Todos
```

We will define a structure for our response and then write tests for the index, show, create, update, and destroy actions.

```ruby
require "rails_helper"

RSpec.describe "Todos", type: :request do
  let(:expected_todo_structure) do
    {
      "id"=> Integer,
      "body" => String,
      "is_completed" => [TrueClass, FalseClass],
    }
  end
end
```

Here we include a variable `expected_todo_structure` which is a hash that defines the structure of the response we expect from the API; id, body, and is_completed.

```ruby
  describe "GET /index" do
    before do
      create_list(:todo, 10)
      get "/todos"
      @body = JSON.parse(response.body)
    end

    it "returns todos" do
      @body.each do |todo|
        expect(todo.keys).to contain_exactly(*expected_todo_structure.keys)
      end
    end

    it "returns http success" do
      expect(response).to have_http_status(:success)
    end

    it 'does not return empty if todos exist' do
      expect(@body).not_to be_empty
    end

    it 'returns 10 todos' do
      expect(@body.size).to eq(10)
    end
  end
```

Here is an example of using `expected_todo_structure` to help define the structure of our response.

Below is the full test for the todo controller.

```ruby
require "rails_helper"

RSpec.describe "Todos", type: :request do
  let(:expected_todo_structure) do
    {
      "id"=> Integer,
      "body" => String,
      "is_completed" => [TrueClass, FalseClass],
    }
  end

  describe "GET /index" do
    before do
      create_list(:todo, 10)
      get "/todos"
      @body = JSON.parse(response.body)
    end

    it "returns todos" do
      @body.each do |todo|
        expect(todo.keys).to contain_exactly(*expected_todo_structure.keys)
      end
    end

    it "returns http success" do
      expect(response).to have_http_status(:success)
    end

    it 'does not return empty if todos exist' do
      expect(@body).not_to be_empty
    end

    it 'returns 10 todos' do
      expect(@body.size).to eq(10)
    end
  end

  describe "GET /show" do
    let (:todo_id) { create(:todo).id }

    before do
      get "/todos/#{todo_id}"
      @body = JSON.parse(response.body)
    end

    it 'checks for the correct structure ' do
      expect(@body.keys).to contain_exactly(*expected_todo_structure.keys)
    end

    it "returns http success" do
      expect(response).to have_http_status(:success)
    end
  end

  describe "POST /create" do

    before do
      post "/todos", params:  attributes_for(:todo)
      @body = JSON.parse(response.body)

    end

    it 'checks for the correct structure ' do
      expect(@body.keys).to contain_exactly(*expected_todo_structure.keys)
    end

    it 'count of todos should increase by 1' do
      expect(Todo.count).to eq(1)
    end

    it "returns http success" do
      expect(response).to have_http_status(:success)
    end
  end

  describe "PUT /update" do
    let (:todo_id) { create(:todo).id }

    before do
      put "/todos/#{todo_id}", params: { body: 'updated body' }
      @body = JSON.parse(response.body)
    end

    it 'checks for the correct structure ' do
      expect( @body.keys).to contain_exactly(*expected_todo_structure.keys)
    end

    it 'checks if the body is updated' do
      expect(Todo.find(todo_id).body).to eq('updated body')
    end

    it "returns http success" do
      expect(response).to have_http_status(:success)
    end
  end

  describe "delete /destroy" do
    let (:todo_id) { create(:todo).id }

    before do
      delete "/todos/#{todo_id}"
    end

    it 'decrements the count of todos by 1' do
      expect(Todo.count).to eq(0)
    end

    it "returns http success" do
      expect(response).to have_http_status(:success)
    end
  end
end
```

```bash
bundle exec rspec
```

We have now created tests for the todo model and the todo controller.

We should expect all the tests to fail since we have not yet created the todo model and the todo controller.

### Passing Todo Model Tests

Let's focus on the todo model first.

```bash
bundle exec rspec spec/models/todo_spec.rb
```

We will then create a new model for the todo list using the following command:

```bash
rails g model Todo body:string is_completed:boolean
```

```text
germancruz@codecoachthree todo_list_api % rails g model Todo body:string is_completed:boolean

      invoke  active_record
      create    db/migrate/20240130191634_create_todos.rb
      create    app/models/todo.rb
      invoke    rspec
    conflict      spec/models/todo_spec.rb
    Overwrite /Users/germancruz/Documents/ruby-on-rails-projects-codelabs/fs_part_one/todo_list_api/spec/models/todo_spec.rb? (enter "h" for help) [Ynaqdhm] n
        skip      spec/models/todo_spec.rb
      invoke      factory_bot
    conflict        spec/factories/todos.rb
      Overwrite /Users/germancruz/Documents/ruby-on-rails-projects-codelabs/fs_part_one/todo_list_api/spec/factories/todos.rb? (enter "h" for help) [Ynaqdhm] n
        skip        spec/factories/todos.rb
```

Include no to the prompts to prevent overwriting the todo_spec.rb and factory bot for todos.

```bash
rails db:migrate
```

Let's pass these tests by adding the following validations to the todo model.

```ruby
class Todo < ApplicationRecord
  validates :body, presence: true, length: { maximum: 255 }
  validates :is_completed, inclusion: { in: [true, false] }
end
```

The key argument `inclusion` is used to validate that the value of the attribute is included in a given set. In this case, the value of the attribute `is_completed` should be either true or false. Otherwise, the validation will fail.

>**üí° Want to see examples of custom validation methods or error messages in Rails?**  
> Ask the [Codelabs Learning Assistant](https://chatgpt.com/g/g-68484cbcb348819181c3f4137b0b7c49-codelabs-learning-assistant): ‚ÄúShow me how to write a custom validation and display a custom error message in a Rails model.‚Äù

### Passing Todo Controller Tests

Let's create the routes for the user and the todo list.

```ruby
Rails.application.routes.draw do
  resources :todos
end
```

```bash
rails g controller todos
```

```text
germancruz@codecoachthree todo_list_api % rails g controller todos
      create  app/controllers/todos_controller.rb
      invoke  rspec
    conflict    spec/requests/todos_spec.rb
  Overwrite /Users/germancruz/Documents/ruby-on-rails-projects-codelabs/fs_part_one/todo_list_api/spec/requests/todos_spec.rb? (enter "h" for help) [Ynaqdhm] n
        skip    spec/requests/todos_spec.rb
```

Let's skip the prompt to prevent overwriting the todos_spec.rb file.

We will proceed to adding serialization to our API by including the blueprinter gem in the Gemfile. Please provide the gemfile in all environments.

```ruby
# Use Rack CORS for handling Cross-Origin Resource Sharing (CORS), making cross-origin Ajax possible
# gem "rack-cors"
gem 'blueprinter'

group :development, :test do
  # See https://guides.rubyonrails.org/debugging_rails_applications.html#debugging-with-the-debug-gem
  gem "debug", platforms: %i[ mri mswin mswin64 mingw x64_mingw ]
  gem 'rspec-rails'
  gem 'factory_bot_rails'
  gem 'faker'
end
```

```bash
bundle install
```

Let's define a serializer for the todo model since our tests require a specific structure for the response.

```ruby
rails g blueprinter:blueprint todo
```

```ruby
# frozen_string_literal: true

class TodoBlueprint < Blueprinter::Base
  identifier :id

  view :normal do
    fields :body, :is_completed
  end
end
```

```ruby
class TodosController < ApplicationController
  before_action :set_todo, only: [:show, :update, :destroy]

  def index
    todos = Todo.all
    render json: TodoBlueprint.render(todos, view: :normal), status: :ok
  end

  def show
    render json: TodoBlueprint.render(@todo, view: :normal), status: :ok
  end

  def create
    todo = Todo.new(todo_params)

    if todo.save
      render json: TodoBlueprint.render(todo, view: :normal), status: :created
    else
      render json: todo.errors, status: :unprocessable_entity
    end
  end

  def update

    if @todo.update(todo_params)
      render json: TodoBlueprint.render(@todo, view: :normal), status: :ok
    else
      render json: @todo.errors, status: :unprocessable_entity
    end
  end

  def destroy
    if @todo.destroy
      render json: nil, status: :ok
    else
      render json: @todo.errors, status: :unprocessable_entity
    end
  end

  private

  def set_todo
    @todo = Todo.find(params[:id])
  end
  def todo_params
    params.permit(:body, :is_completed)
  end
end
```

Great! We have now passed all the tests for the todo model and the todo controller.

We didn't even have to use postman to test our API. We were able to test our API using RSpec.

## Full Stack Overview

Reminder, we are building a full stack project using Ruby on Rails for the back end and Angular for the front end. This means our front end application will be able to send requests to the back end application and the back end application will be able to send responses to the front end application.

Since both applications create local servers, we will have to run both servers at the same time.

In your Rails API, run the command to start the server:

```bash
rails s
```

When we have both servers running, we can then send requests from the front end to the back end in our local environment. Our computer will be aware of both servers.

## Angular Front End

Let's create the Angular front end for the todo list api. We will focus strictly on CRUD operations for quick demonstration.

### Angular Project Setup

We will be using Angular 19 for the frontend of our project.

To make sure you are able to create Angular 19 projects, run the following command:

```bash
ng version
```

You should see a similar output:

```bash

     _                      _                 ____ _     ___
    / \   _ __   __ _ _   _| | __ _ _ __     / ___| |   |_ _|
   / ‚ñ≥ \ | '_ \ / _` | | | | |/ _` | '__|   | |   | |    | |
  / ___ \| | | | (_| | |_| | | (_| | |      | |___| |___ | |
 /_/   \_\_| |_|\__, |\__,_|_|\__,_|_|       \____|_____|___|
                |___/


Angular CLI: 19.0.0
Node: 20.11.0
Package Manager: npm 10.2.4
OS: darwin x64

Angular:
...

Package                      Version
------------------------------------------------------
@angular-devkit/architect    0.1900.0 (cli-only)
@angular-devkit/core         19.0.0 (cli-only)
@angular-devkit/schematics   19.0.0 (cli-only)
@schematics/angular          19.0.0 (cli-only)
```

You should see 19 as the version of Angular. If you do not see 19, you will need to update your Angular CLI and possibly Node.js.

```bash
germancruz@codecoachthree ruby-on-rails-projects-codelabs % ng new fe_todo_list
? Which stylesheet format would you like to use? SCSS   [ https://sass-lang.com/documentation/syntax#scss                ]

? Do you want to enable Server-Side Rendering (SSR) and Static Site Generation (SSG/Prerendering)? N
```

Server-Side Rendering (SSR) and Static Site Generation (SSG/Prerendering) are not necessary for this project. If you like to learn more about SSR and SSG, you can visit this [article](https://javascript.plainenglish.io/server-side-rendering-explained-in-brief-words-angular-17-76d23a30ae24).

### Creating a Model for the Todo List

A model is a class or interface or a data structure that represents the data in the application.

Let's create a model for the todo list.

```bash
ng g class models/todo
```

```typescript
export class Todo {
	id: number = -1;
	body: string = '';
	is_completed: boolean = false;
}
```

### Creating a Service for the Todo List

A service is a class that can be used to share data between different components. We will use a service to make requests to the Rails API.

Let's create a service for the todo list.

```bash
ng g s services/todo
```

```typescript
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import { Todo } from '../models/todo';

@Injectable({
	providedIn: 'root',
})
export class TodoService {
	private url = 'http://localhost:3000/todos';

	constructor(private http: HttpClient) {}

	getTodos(): Observable<Todo[]> {
		return this.http.get<Todo[]>(this.url);
	}

	getTodoById(id: number): Observable<Todo> {
		return this.http.get<Todo>(`${this.url}/${id}`);
	}

	createTodo(todo: { body: string; is_completed: boolean }): Observable<Todo> {
		return this.http.post<Todo>(this.url, todo);
	}

	updateTodo(todo: Todo): Observable<Todo> {
		return this.http.put<Todo>(`${this.url}/${todo.id}`, todo);
	}

	deleteTodo(id: number): Observable<Todo> {
		return this.http.delete<Todo>(`${this.url}/${id}`);
	}
}
```

In this service we have defined methods to make requests to the Rails API. Each method allows us to make a specific request to the API.

-   `getTodos` - This method makes a GET request to the API to get all the todos.
-   `getTodoById` - This method makes a GET request to the API to get a specific todo by its id.
-   `createTodo` - This method makes a POST request to the API to create a new todo.
-   `updateTodo` - This method makes a PUT request to the API to update a todo.
-   `deleteTodo` - This method makes a DELETE request to the API to delete a todo.

In order to set up the service to be able to make requests to our Rails API, we need to configure the app.config.ts file. This is the Angular 17 equivalent of the app.module.ts file.

**app.config.ts**
```typescript 
import { ApplicationConfig } from '@angular/core';
import { provideRouter } from '@angular/router';

import { routes } from './app.routes';
import { provideHttpClient } from '@angular/common/http';

export const appConfig: ApplicationConfig = {
  providers: [provideRouter(routes), provideHttpClient()]
};
```

Here I am importing providedHttpClient from the @angular/common/http module and providing it in the appConfig. This will allow us to use the HttpClient module in our service.

### Creating a Component for the Todo List

Remember, a component in Angular represents a part of the user interface.

Let's create a component for the todo list.

```bash
ng g c todo-list --standalone
```

```typescript
import { Component, OnInit } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { TodoService } from '../services/todo.service';
import { Todo } from '../models/todo';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-todo-list',
  standalone: true,
  imports: [FormsModule, CommonModule],
  templateUrl: './todo-list.component.html',
  styleUrl: './todo-list.component.scss'
})
export class TodoListComponent implements OnInit{
  todos: Todo[] = [];
  newTodoBody: string = ''; // Property to hold the new todo input value

  constructor(private todoService: TodoService) { }

  ngOnInit(): void {
    this.todoService.getTodos().subscribe(todos => this.todos = todos);
  }

  addTodo() {
    if (!this.newTodoBody.trim()) {
      // Prevent adding empty todos
      return;
    }

    const todo = {
      body: this.newTodoBody,
      is_completed: false
    };

    this.todoService.createTodo(todo).subscribe(newTodo => {
      this.todos.push(newTodo);
      this.newTodoBody = ''; // Reset the input field after adding
    });
  }

  updateTodo(todo: Todo) {
    this.todoService.updateTodo(todo).subscribe(updatedTodo => {
      const index = this.todos.findIndex(t => t.id === updatedTodo.id);
      this.todos[index] = updatedTodo;
    });
  }

  deleteTodo(id: number) {
    this.todoService.deleteTodo(id).subscribe({
      next: () => this.todos = this.todos.filter(todo => todo.id !== id),
      error: (err) => console.error(err)
    });
  }
}
```

In this component, we have defined methods to add, update, and delete todos. We have also defined a method to get all the todos when the component is initialized.

-   `addTodo` - This method adds a new todo to the list of todos.
-   `updateTodo` - This method updates a todo in the list of todos.
-   `deleteTodo` - This method deletes a todo from the list of todos.
-   `ngOnInit` - This method gets all the todos when the component is initialized.
-   `newTodoBody` - This property holds the value of the new todo input field.

### Creating a View for the Todo List

Let's create a view for the todo list.

```html
<h1>Todo List</h1>

<!-- Todo form -->
<div class="todo-form">
	<input type="text" [(ngModel)]="newTodoBody" placeholder="Add a new todo..." />
	<button (click)="addTodo()">Add Todo</button>
</div>

<!-- Todo list -->
<ul>
	<li *ngFor="let todo of todos">
		<input type="checkbox" [(ngModel)]="todo.is_completed" (change)="updateTodo(todo)" />
		<span>{{ todo.body }}</span>
		<button (click)="deleteTodo(todo.id)">Delete</button>
	</li>
</ul>
```

### Styling the Todo List

Let's create detailed styles for the todo list.

```scss
/* Heading styles */
h1 {
	color: #333;
	text-align: center;
	font-family: Arial, sans-serif;
}

/* Styles for the Todo list container */
ul {
	list-style-type: none;
	padding: 0;
	margin: 0 auto;
	max-width: 600px;
}

/* Styles for each Todo item */
li {
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 10px;
	border-bottom: 1px solid #ccc;
}

/* Styles for Todo text */
span {
	margin-left: 10px;
}

/* Checkbox styles */
input[type='checkbox'] {
	margin: 0 10px;
}

/* Button styles */
button {
	padding: 5px 10px;
	margin-left: 10px;
	border: none;
	border-radius: 5px;
	cursor: pointer;
}

/* Create Todo button specific styles */
button:first-of-type {
	background-color: #4caf50; /* Green */
	color: white;
}

/* Delete button specific styles */
button:not(:first-of-type) {
	background-color: #f44336; /* Red */
	color: white;
}

/* Hover effects for buttons */
button:hover {
	opacity: 0.8;
}

.todo-form {
	display: flex;
	justify-content: center;
	margin: 20px 0 20px 0;
}
```

Let's include the todo list component in the app component.

```typescript
import { Component } from '@angular/core';
import { TodoListComponent } from './todo-list/todo-list.component';

@Component({
	selector: 'app-root',
	standalone: true,
	templateUrl: './app.component.html',
	styleUrl: './app.component.scss',
	imports: [TodoListComponent],
})
export class AppComponent {}
```

Be sure to import the TodoListComponent in the app component.

**app.component.html**
```html
<app-todo-list />
```

### Running the Application

In the terminal of the Angular project, run the following command to start the server:

```bash
ng serve
```

Also make sure the Rails API server is running.

When we start the Angular server, we can then access the application in the browser at `http://localhost:4200`.

We then notice we get an error in the console.

```bash
Access to XMLHttpRequest at 'http://localhost:3000/todos' from origin 'http://localhost:4200' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
```

This is because the Rails API is not allowing requests from the Angular front end. This is due to there being what is called a CORS issue. CORS is a security feature that prevents requests from other domains from accessing the API's resources. Let's go ahead and fix this.

### Fixing CORS

We will fix this by adding the `rack-cors` gem to the Rails API.

rack-cors is a gem that allows you to configure the CORS policy for your Rails API. It's helpful for allowing requests from other domains to access the API.

Let's stop the server. 

Add the following to the Gemfile:

```ruby
gem 'rack-cors'
```

Then run the following command:

```bash
bundle install
```

Next, add the following to the `config/initializers/cors.rb` file:

```ruby
Rails.application.config.middleware.insert_before 0, Rack::Cors do
  allow do
    origins '*'
    resource '*', headers: :any, methods: [:get, :post, :put, :patch, :delete, :options, :head]
  end
end
```

This is a simple configuration that allows requests from any origin to access the API. In a production environment, you would want to restrict this to only the domains that you trust. You can do this by replacing the `*` with the domain you trust.


### Running the Application

Be sure both servers are running. And test the application in the browser at `http://localhost:4200` by adding a new todo, updating a todo (by checking the checkbox), and deleting a todo.

### Conclusion

Great!

We have now created a full stack project using Ruby on Rails for the back end and Angular for the front end.

## References

-   [Ruby on Rails](https://rubyonrails.org/)
-   [Angular](https://angular.io/)
-   [RSpec](https://rspec.info/)
